[{"content":"The Motivation Currently when you make an Azure Functions project you have a local.settings.json file where you setup environment rules to do with the runtime frameworks, CORs settings etc - you can also configure \u0026lsquo;application settings\u0026rsquo; that will be exposed as environment variables during runtime.\nThere are three things I would like to change about this:\n I would like to separate the concerns by keeping environment configuration in one place, and my application/logic specific settings elsewhere. It is not best practice to distribute sensitive settings by committing them into the repository - we need a different way of doing this. Currently you would have to commit the local.settings.json to distribute the sensitive values. Once local.settings.json contains no sensitive values I\u0026rsquo;d like to remove it from the .gitignore so that each member of the team will have the same local configuration.  Setup Enable User Secrets  User secrets are a tool built into .NET to allow developers to store secret information outside of the project root. It makes it less likely that secrets are accidentally committed to source control.\n Right click on the project in Visual Studio and select Manage User Secrets - this will add any required NuGet packages and alter the project file where necessary.\nOnce you have followed the required steps you should be able to click on Manage User Secrets again and an empty secrets.json file will open. This indicates that user secrets has been correctly setup.\nAdd appsettings.json file In the root of your project create an appsettings.json file and setup the insensitive values you want to store. Here is an example.\n// appsettings.json { \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;MyConnectionString\u0026#34;: \u0026#34;\u0026#34; // This value will be stored in user secrets - hence empty // (but we put it in here to remind us there is actually a value somewhere!) }, \u0026#34;General\u0026#34;: { \u0026#34;RandomColour\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;Shape\u0026#34;: \u0026#34;triangle\u0026#34; } } You also need to make sure that the appsettings.json file is set to copy to your build output:\n\u0026lt;None Update=\u0026#34;appsettings.json\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;PreserveNewest\u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/None\u0026gt; Add sensitive settings to User Secrets You can see above that we store insensitive values directly in appsettings.json, but we will merge together our user secrets and these values to create our final configuration that the application has access to.\nOpen your secrets.json file and put your sensitive settings inside. E.g:\n// secrets.json { \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;MyConnectionString\u0026#34;: \u0026#34;my-sensitive-connection-string-1234-abcd\u0026#34; }, // Note we didn\u0026#39;t need the General section as this is taken from appsettings.json } Create options classes To access the settings during runtime we will use dependency injection of different Options classes, we need to make these classes.\nFor our examples above we will create two classes, one for each of the sections; ConnectionStrings and General:\nConfiguration/ ConnectionStrings.cs General.cs // ConnectionStrings.cs  namespace MyProject.Configuration { public class ConnectionStrings { public string RandomColour { get; set; } public string Shape { get; set; } } } // General.cs  namespace MyProject.Configuration { public class General { public string MyConnectionString { get; set; } } } Install required packages for Dependency Injection We need to install some NuGet packages to make sure that we will be able to inject our Options classes into our functions:\n Microsoft.Azure.Functions.Extensions Microsoft.NET.Sdk.Functions ( \u0026gt;= 1.0.28 ) Microsoft.Extensions.DependencyInjections ( \u0026lt;= 3.x )  Create functions setup class to configure everything We will now create a startup class that will read values from our appsettings.json, our user secrets (and environment variables), merge them together into sections and then load into our preconfigured options objects. It will then finally register these options objects so our functions can request them via dependency injection.\nThe class should be called Startup.cs and be at the root of your project. Here is an example:\n// Startup.cs  using System; using System.IO; using MyProject.Configuration; using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; [assembly: FunctionsStartup(typeof(MyProject.Startup))] namespace MyProject { public class Startup : FunctionsStartup { private bool IsDevelopment =\u0026gt; string.Equals(Environment.GetEnvironmentVariable(\u0026#34;AZURE_FUNCTIONS_ENVIRONMENT\u0026#34;), \u0026#34;Development\u0026#34;, StringComparison.OrdinalIgnoreCase); /// \u0026lt;summary\u0026gt;  /// Loads in settings from various sources including environment / user secrets / appsettings  /// and binds them to various options objects  /// \u0026lt;/summary\u0026gt;  public override void Configure(IFunctionsHostBuilder builder) { // Bind connection strings  builder.Services.AddOptions\u0026lt;ConnectionStrings\u0026gt;().Configure\u0026lt;IConfiguration\u0026gt;((settings, configuration) =\u0026gt; { configuration.GetSection(nameof(ConnectionStrings)).Bind(settings); }); // Bind general settings  builder.Services.AddOptions\u0026lt;General\u0026gt;().Configure\u0026lt;IConfiguration\u0026gt;((settings, configuration) =\u0026gt; { configuration.GetSection(nameof(General)).Bind(settings); }); } /// \u0026lt;summary\u0026gt;  /// Defines the sources in which to load application settings from so they can be used above  /// \u0026lt;/summary\u0026gt;  public override void ConfigureAppConfiguration(IFunctionsConfigurationBuilder builder) { FunctionsHostBuilderContext context = builder.GetContext(); builder.ConfigurationBuilder .AddJsonFile(Path.Combine(context.ApplicationRootPath, \u0026#34;appsettings.json\u0026#34;), optional: true); if (IsDevelopment) { builder.ConfigurationBuilder.AddUserSecrets\u0026lt;Startup\u0026gt;(); } else { builder.ConfigurationBuilder.AddEnvironmentVariables(); } } } } Accessing the settings during runtime You now need to request the options objects via dependency injection in your function. Here is an example:\n// MyFunction.cs  ... private readonly IOptions\u0026lt;ConnectionStrings\u0026gt; _connectionStrings; private readonly IOptions\u0026lt;General\u0026gt; _settings; public MyFunction(IOptions\u0026lt;ConnectionStrings\u0026gt; connectionStrings, IOptions\u0026lt;General\u0026gt; settings) { _connectionStrings = connectionStrings; _settings = settings; } ... // Access a setting var shape = _settings.Value.Shape Testing the application If you now run the functions project locally you should find values stored in either user secrets or directly in appsettings.json are accessible at runtime! ðŸŽ‰ðŸŽ‰\nDeployment User secrets are not supported when deployed, hence you need to move your sensitive values to environment variables when deployed. The values hardcoded into appsettings.json will still be read. You may have noticed this in Startup.cs that we merge from different locations depending on the environment.\nThere is just once small factor you need to be made aware of. You have have to flatten your JSON when naming your environment variables. For example the following setting in our user secrets:\n{ \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;MyConnectionString\u0026#34;: \u0026#34;my-sensitive-connection-string-1234-abcd\u0026#34; } } becomes the following environment variable (using double underscore__ to indicate nesting):\nConnectionStrings__MyConnectionString = \u0026quot;my-sensitive-connection-string-1234-abcd\u0026quot; Documentation When a new member of your team comes to work on your project they will not have their user secrets setup correctly so their project will not run as expected.\nWe suggest adding a section to your README that indicates what the layout of their secrets.json should be, and where they could get the value from.\n// Please setup your secrets.json as follows, // the connection string can be found in the company password vault. { \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;MyConnectionString\u0026#34;: \u0026#34;\u0026lt;IN_PASSWORD_VAULT\u0026gt;\u0026#34; } } References  https://docs.microsoft.com/en-us/azure/azure-functions/functions-dotnet-dependency-injection https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0\u0026amp;tabs=windows  ","permalink":"https://dombarter.co.uk/posts/azure-functions-app-settings/","summary":"How to separate the concerns of environment configuration and application configuration in an azure functions project and distribute sensitive settings via user secrets and environment variables.","title":"Adding app settings and user secrets to an Azure Functions project"},{"content":"What Is Hexos? Hexos is the name of my self-employed business, through which I develop web applications, mobile applications as well as provide general IT solutions.\nWhat Is \u0026lsquo;Heatmaps By Hexos\u0026rsquo;? Heatmaps by Hexos is one of the web/cloud applications I developed and ran between 2019 and 2022. It was a successful business that sold heatmap images to schools and colleges across the UK.\n Hexos has developed a service that can create heatmaps / travel time maps to visualise public transport and driving commute times travelling towards or from a central point within a given radius. Heatmaps can be generated for any time of day, any day of the week and any location in the United Kingdom.\n The Tech Stack The tech stack was as follows:\n Express web application - Node.js AWS Lambda micro-services - Node.js AWS SQS (Simple Queue Service) AWS DynamoDB (NoSQL Object Database) Bootstrap Front-End Leaflet.js Map Provider Google Maps Directions API  An Example Of The End Product The main product that Heatmaps By Hexos generated was a selection of high definition images (also viewable as a interactive online version) - showing the travel times for the given configuration (postcode, day of the week, time of the day, transit type etc).\nHere is an example:\nA Guide Around The Web Application I\u0026rsquo;ll try to show you what the web application looked like, and how customers went through the process of requesting a heatmap from us.\nLogin Page Customers could login and sign up via our secure login and register pages. We also had forgot password functionality that would send out a reset password link with a 24 hour expiry.\nDashboard On the dashboard, the user had access to all the heatmaps they had previously or actively requested. Each heatmap was described by the postcode it represented. You could track the status of a heatmap if it was currently in the process of being generated, and once generated, view the interactive heatmap or download the images.\nRequest Heatmap On this page, the customer used pre-purchased credits to request a heatmap, by defining multiple settings:\nThe size of the heatmap defined the maximum search radius - that is, how far the algorithm would search for possible routes. The postcode represented the centre of the heatmap, either where all journeys started or finished. The map would update to place a pin at the postcode they had picked. The journeys could either be calculated by using routes taken by car, or routes taken public transport.\nThey then had to decide whether the heatmap was inbound or outbound. Inbound heatmaps would consider the latest time required to leave at a location to arrive at the centre by a given time. Outbound heatmaps would consider the earliest time you could arrive at a point, given you left the centre at a given time. The arrival or departure time would need to be set dependant on if they had picked an inbound or outbound heatmap. The day of the week then had to be picked, so that the algorithm could look at relevant routes. For example traffic may be worse in the week, or public transport not as frequent on a weekend. The user then had to submit their request - at which point the heatmap would begin processing on the AWS cloud system. When the user requested a heatmap they would receive an email: And another email when the heatmap was ready. Interactive Heatmap Viewer The interactive heatmap viewer was very similar to the downloadable images, except it let you zoom in much further, click on any cell to get specific route information, and change the maximum time filter.\nAccount Settings There was also an account settings page where you could view all the information we stored, as well as change useful settings such as turning email updates off.\nPurchase Credits Customers had to buy credits through the online dashboard that would then be credited to their account. They could then use these credits against eligible heatmap requests.\nFor example a city heatmap would cost 2 credits.\nPayments were processed through Stripe.\nHeatmap Download The user could then download a zip folder of images, in 4 definitions ranging from 512x512 to 3072x3072. The images were then broken up into 5 maximum time filters, from 1 to 3 hours.\nWe also supplied the user with a GeoJSON file with all the heatmap data, so they could make their own images.\nWhat Has Happened To \u0026lsquo;Heatmaps By Hexos\u0026rsquo; Now? Heatmaps by Hexos was a successful business that sold heatmap images to schools and colleges across the UK. They used these images to find new recruitment areas for students to come from that they hadn\u0026rsquo;t previously considered.\nIn 2022 I made the tough decision to shut this service down in order to focus on my professional development as a software engineer in industry. Other factors included the increasing time required to maintain the online service, especially with the speed at which frameworks such as Node.js are moving.\nI learnt invaluable lessons whilst building this product as well as building my network of connections, and I am sure that this is not the last we will see of Hexos!\nOther Resources \u0026amp; Information These items are considered as archived - but give some extra details about specific parts of Heatmaps by Hexos, and therefore may be of interest. These items were mainly used as marketing material.\nSheffield Digital Interview \nHeatmap Handbook The Heatmap Handbook\nService Overview Service Overview\nExample Heatmap Download heatmap.zip\n","permalink":"https://dombarter.co.uk/projects/hexos/","summary":"Running between 2019 and 2022, Hexos was a UK provider of realistic driving and public transport based heatmaps/travel-time maps for data visualisation.","title":"Heatmaps By Hexos"},{"content":"What does x.y.z stand for? In a given version number, x.y.z stands for major.minor.patch.\nE.g 1.2.4 means:\n Major release: 1 Minor release: 2 Patch release: 4  Major Versions Major versions should be incremented when you introduce huge change to a project, and specifically when you are making something no longer backwards compatible.\nMinor Versions Minor versions should be incremented when you introduce a new feature or a small to medium change. The product remains mostly the same but you have introduced something new.\nPatch Versions Patch versions should be incremented when you fix a bug, or tweak a small setting. A very small change.\nIncrementing Version Numbers When incrementing versions, major takes priority over minor and minor takes priority over patch. This means when you increment a minor version, the patch version gets reset to 0, and when you increment a major version, the minor version is reset to 0. For example:\n 1.0.0 1.0.1 1.1.0 1.2.0 2.0.0  ","permalink":"https://dombarter.co.uk/posts/semantic-versioning/","summary":"How to correctly version things using the x.y.z format","title":"Semantic Versioning"},{"content":"When did I learn about GitFlow? I learnt about GitFlow during my placement at 3squared, as it was the agreed method for managing branches across the different products and teams. As placement students we had to fully understand how GitFlow worked before we could start working on any of the companies products.\nWhy is GitFlow helpful? GitFLow helps large teams manage new features, deployments, hotfixes and ensuring there is a chain-of-command in respect of code moving between branches.\nHow does GitFlow work? Image from Medium\nThe branches  master: This branch mirrors the state of the deployed environment. develop: This branch contains a collection of all the most up to date features. feature/*: These branches are based off develop and are where the new changes are written, before being merged back into develop. release/*: These branches are based off develop and are where you make final config changes ready to be deployed to a specific environment prior to being merged into master. hotfix/*: These branches are based off master to make quick fixes that can be quickly be merged back into master to be deployed.  Starting a new feature You\u0026rsquo;ve just been assigned a ticket and it\u0026rsquo;s time to start coding! You will want to create a new feature branch based off develop. For example feature/add-profile-page. Put all your commits and changes related to a given ticket/workload on this branch. Once you have finished your changes open a pull request from your feature branch to develop.\nWhen doing feature work you will simply by winding in and out of develop.\nCode reviewing Whenever work wants to be moved onto the develop branch it must be peer reviewed by a senior developer. As a junior developer this is great because you can receive feedback but it also ensures code style is maintained and no glaring issues are introduced. It also means code can enter the the develop branch without people knowing about it!\nDeployments There is now a collection of tickets on the develop branch ready to be deployed. At this point a new release branch will be made such as release/001.002.000 based off develop. On this branch you can make final config changes such as changing database connection strings to live ones rather than local ones.\nOnce this is ready you should merge the release branch into master and perform your deployment.\nHotfixes If there are any issues on production environment and you need a quicker fix than following the \u0026lsquo;feature -\u0026gt; develop -\u0026gt; release -\u0026gt; master\u0026rsquo; route, you can make a hotfix branch. Eg. hotfix/001.002.001. In this branch you can make brief changes and quickly get them deployed.\nThis hotfix branch should be merged into master to be deployed, and back into develop to ensure your changes don\u0026rsquo;t get lost.\nMore information You can read more about GitFlow in this Atlassian guide\n","permalink":"https://dombarter.co.uk/posts/introduction-to-git-flow/","summary":"Introducing GitFlow, a well established method of branching in a git repository with multiple members","title":"Introduction to Git Flow"},{"content":"This is my about page, I still need to write it!\n","permalink":"https://dombarter.co.uk/about/","summary":"This is my about page, I still need to write it!","title":"About"},{"content":"Ever wondered what happens when you fill a computer screen with llamas?\nNo I don\u0026rsquo;t think many people have!\nWell it turns out I wanted to find out\u0026hellip;\nBuilt in plain HTML, CSS and JavaScript with help from Phaser.js - please go and enjoy my llama physics engine:\ndombarter.co.uk/llama/\nAnd if you\u0026rsquo;re interested in the source code:\nView GitHub repository\n","permalink":"https://dombarter.co.uk/projects/llamas/","summary":"It\u0026rsquo;s llamas and physics. Who knows what could happen?","title":"Llama Physics Engine"}]